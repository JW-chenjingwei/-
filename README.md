## 计算机组成原理 笔记

### 体系图
![计算机组成原理](https://github.com/JW-chenjingwei/Computer-composition-principle-notes/blob/master/%E4%B8%8B%E8%BD%BD.jpeg)
### 冯诺依曼体系结构:
* 运算器
* 控制器
* 存储器
* 输入设备
* 输出设备输出
### 计算机两个核心指标：
* 性能和功耗

### 性能是指什么?
* 时间的倒数~
1. 响应时间
2. 吞吐率(带宽

* 程序的 CPU 执行时间 = CPU 时钟周期数)×时钟周期时间(CPU主频) = (指令数×每条指令的平均时钟周期数) * 时钟周期时间 
* 因此，如果我们想要解决性能问题，其实就是要优化这三者:
1. 时钟周期时间，就是计算机主频，这个取决于计算机硬件。我们所熟知的摩尔定律就一直在不停地提高我们计算机的主频。比如说，我最早使用的 80386 主频只有 33MHz，现在手头的笔记本电脑就有 2.8GHz，在主频层面，就提升了将近 100 倍。

2. 每条指令的平均时钟周期数 CPI，就是一条指令到底需要多少 CPU Cycle。在后面讲解 CPU 结构的时候，我们会看到，现代的 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU Cycle 尽可能地少。因此，对于 CPI 的优化，也是计算机组成和体系结构中的重要一环。

3. 指令数，代表执行我们的程序到底需要多少条指令、用哪些指令。这个很多时候就把挑战交给了编译器。同样的代码，编译成计算机指令时候，就有各种不同的表示方式。

### 穿越功耗墙，我们该从哪些方面提升“性能”？

* 功耗 ~= 1/2 ×负载电容×电压的平方×开关频率×晶体管数量
* 增加晶体管数量,增加晶体管密度,缩小芯片面积,晶体管之间的距离变小,传输速度越快
* 降低电压,由于功耗和电压的平方是成正比,比如下载1/5的电压,功耗就下降了1/25
* 并行优化,提高吞吐率
>> 但是，并不是所有问题，都可以通过并行提高性能来解决。如果想要使用这种思想，需要满足这样几个条件。

>>第一，需要进行的计算，本身可以分解成几个可以并行的任务。好比上面的乘法和加法计算，几个人可以同时进行，不会影响最后的结果。

>>第二，需要能够分解好问题，并确保几个人的结果能够汇总到一起。

第三，在“汇总”这个阶段，是没有办法并行进行的，还是得顺序执行，一步一步来。

### 阿姆达尔定律
* 对于一个程序进行优化之后，处理器并行运算之后效率提升的情况。具体可以用这样一个公式来表示：

* 优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 不受影响的执行时间

### 在“摩尔定律”和“并行计算”之外，在整个计算机组成层面，还有这样几个原则性的性能提升方法。
1. 加速大概率事件:最典型的就是，过去几年流行的深度学习，整个计算过程中，99% 都是向量和矩阵计算，于是，工程师们通过用 GPU 替代 CPU，大幅度提升了深度学习的模型训练过程。本来一个 CPU 需要跑几小时甚至几天的程序，GPU 只需要几分钟就好了。Google 更是不满足于 GPU 的性能，进一步地推出了 TPU。
2. 通过流水线提高性能:现代的工厂里的生产线叫“流水线”。我们可以把装配 iPhone 这样的任务拆分成一个个细分的任务，让每个人都只需要处理一道工序，最大化整个工厂的生产效率。类似的，我们的 CPU 其实就是一个“运算工厂”。我们把 CPU 指令执行的过程进行拆分，细化运行，也是现代 CPU 在主频没有办法提升那么多的情况下，性能仍然可以得到提升的重要原因之一。我们在后面也会讲到，现代 CPU 里是如何通过流水线来提升性能的，以及反面的，过长的流水线会带来什么新的功耗和效率上的负面影响。
3. 通过预测提高性能:通过预先猜测下一步该干什么，而不是等上一步运行的结果，提前进行运算，也是让程序跑得更快一点的办法。典型的例子就是在一个循环访问数组的时候，凭经验，你也会猜到下一步我们会访问数组的下一项。后面要讲的“分支和冒险”、“局部性原理”这些 CPU 和存储系统设计方法，其实都是在利用我们对于未来的“预测”，提前进行相应的操作，来提升我们的程序性能。

### CPU的工作:执行各种计算机指令

* 不同的CPU能读懂的语言不同,这个就做计算机指令集
* CPU只能读懂由0,1组成的机器码,人们编写的高级语言需要通过编译器编译成汇编语言,汇编语言与机器码一一对应,在实际工作中,汇编器都是直接转成机器码的,汇编预言只是方便人们读懂理解.

### 指令的分类
* 第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。

* 第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。

* 第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。

* 第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。

* 最后一类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。

![指令解析](https://github.com/JW-chenjingwei/Computer-composition-principle-notes/blob/master/%E4%B8%8B%E8%BD%BD%20(1).jpeg)
